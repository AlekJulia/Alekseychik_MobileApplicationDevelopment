#include <iostream>
#include <vector>
#include <random>
#include <cmath>
#include <iomanip>

using namespace std;

int main() {
    setlocale(LC_ALL, "Russian");

    // ============================================================================
    // ПАРАМЕТРЫ СИСТЕМЫ АВТОТРАНСПОРТНОГО ПРЕДПРИЯТИЯ
    // ============================================================================

    // Основные параметры системы
    int n = 10;              // Общее количество автобусов на предприятии
    int m = 3;               // Количество ремонтных линий (операторов)
    double lambda = 0.5;     // Интенсивность поломок автобусов (заявок в единицу времени)
    double mu = 1.0;         // Интенсивность ремонта одного автобуса (обслуживания)

    // Экономические параметры
    double c1 = 100.0;       // Доход в единицу времени от одного работающего автобуса
    double c2 = 50.0;        // Потери в единицу времени от простоя одного автобуса
    double c3 = 30.0;        // Расходы на содержание одной ремонтной линии в единицу времени

    double T_max = 1000.0;   // Общее время моделирования

    // ============================================================================
    // ИНИЦИАЛИЗАЦИЯ ГЕНЕРАТОРА СЛУЧАЙНЫХ ЧИСЕЛ
    // ============================================================================
    random_device rd;
    mt19937 gen(rd());
    uniform_real_distribution<double> uniform(0.0, 1.0);

    // ============================================================================
    // ПЕРЕМЕННЫЕ ДЛЯ МОДЕЛИРОВАНИЯ И СТАТИСТИКИ
    // ============================================================================

    // Основные переменные моделирования
    double t = 0.0;          // Текущее время моделирования
    int k = n;               // Количество работающих автобусов (в начале все работают)
    double total_profit = 0.0; // Общая прибыль предприятия

    // Статистические переменные
    vector<double> time_in_state(n + 1, 0.0);  // Время, проведенное с k работающими автобусами
    int breakdowns_count = 0;    // Счетчик поломок
    int repairs_count = 0;       // Счетчик завершенных ремонтов
    double total_queue_time = 0.0; // Общее время ожидания в очереди
    int max_queue_length = 0;    // Максимальная длина очереди

    cout << fixed << setprecision(2);
    cout << "=== МОДЕЛИРОВАНИЕ РАБОТЫ АВТОТРАНСПОРТНОГО ПРЕДПРИЯТИЯ ===" << endl;
    cout << "Параметры системы:" << endl;
    cout << "• Общее количество автобусов: " << n << endl;
    cout << "• Количество ремонтных линий: " << m << endl;
    cout << "• Интенсивность поломок (лямбда): " << lambda << endl;
    cout << "• Интенсивность ремонта (мю): " << mu << endl;
    cout << "• Время моделирования: " << T_max << endl << endl;

    // ============================================================================
    // ОСНОВНОЙ ЦИКЛ МОДЕЛИРОВАНИЯ (ДИСКРЕТНО-СОБЫТИЙНЫЙ ПОДХОД)
    // ============================================================================

    while (t < T_max) {
        // Сохраняем предыдущее время для расчета интервала
        double previous_time = t;

        // ========================================================================
        // БЛОК 1: ГЕНЕРАЦИЯ ВРЕМЕНИ ДО СЛЕДУЮЩИХ СОБЫТИЙ
        // ========================================================================

        // 1.1 Время до следующей поломки автобуса
        // Генерируем экспоненциально распределенное время с параметром λ*k
        // (чем больше работающих автобусов, тем чаще поломки)
        double u1 = uniform(gen);
        double tau1 = -log(u1) / (lambda * k);

        // 1.2 Время до следующего завершения ремонта
        double tau2;
        int broken_buses = n - k;  // Количество сломанных автобусов

        if (broken_buses > 0) {
            // Интенсивность выхода из ремонта: μ * min(сломанные, ремонтные линии)
            // Если сломанных больше чем линий, работают все линии
            // Если сломанных меньше чем линий, работают только нужные
            double u2 = uniform(gen);
            tau2 = -log(u2) / (mu * min(broken_buses, m));
        }
        else {
            // Если нет сломанных автобусов, ремонтов быть не может
            tau2 = numeric_limits<double>::infinity();
        }

        // ========================================================================
        // БЛОК 2: ВЫБОР БЛИЖАЙШЕГО СОБЫТИЯ И ОБНОВЛЕНИЕ ВРЕМЕНИ
        // ========================================================================

        // Определяем, какое событие произойдет раньше
        double dt = min(tau1, tau2);

        // Корректируем время, если выходим за пределы T_max
        if (t + dt > T_max) {
            dt = T_max - t;
        }

        // ========================================================================
        // БЛОК 3: РАСЧЕТ ПРИБЫЛИ И ОБНОВЛЕНИЕ СТАТИСТИКИ
        // ========================================================================

        // 3.1 Расчет прибыли за текущий интервал времени
        // Прибыль = доходы от работающих - потери от простоев - расходы на ремонт
        double current_profit = (c1 * k - c2 * (n - k) - c3 * m) * dt;
        total_profit += current_profit;

        // 3.2 Обновление статистики времени состояний
        time_in_state[k] += dt;

        // 3.3 Обновление статистики очереди
        int current_queue = max(0, broken_buses - m);  // Автобусы в очереди
        total_queue_time += current_queue * dt;
        if (current_queue > max_queue_length) {
            max_queue_length = current_queue;
        }

        // 3.4 Обновление общего времени
        t += dt;

        // ========================================================================
        // БЛОК 4: ОБРАБОТКА СОБЫТИЙ
        // ========================================================================

        if (tau1 < tau2 && dt == tau1) {
            // СОБЫТИЕ: ПОЛОМКА АВТОБУСА
            k--;  // Уменьшаем количество работающих автобусов
            breakdowns_count++;
        }
        else if (dt == tau2) {
            // СОБЫТИЕ: ЗАВЕРШЕНИЕ РЕМОНТА
            k++;  // Увеличиваем количество работающих автобусов
            repairs_count++;
        }

        // Защита от выхода за границы
        k = max(0, min(n, k));
    }

    // ============================================================================
    // БЛОК 5: ВЫВОД РЕЗУЛЬТАТОВ И СТАТИСТИКИ
    // ============================================================================

    cout << "=== РЕЗУЛЬТАТЫ МОДЕЛИРОВАНИЯ ===" << endl;
    cout << "Общее время моделирования: " << T_max << endl;
    cout << "Общая прибыль предприятия: " << total_profit << endl;
    cout << "Средняя прибыль в единицу времени: " << total_profit / T_max << endl << endl;

    cout << "СТАТИСТИКА СОБЫТИЙ:" << endl;
    cout << "• Всего поломок: " << breakdowns_count << endl;
    cout << "• Всего завершенных ремонтов: " << repairs_count << endl;
    cout << "• Количество работающих автобусов в конце: " << k << endl << endl;

    cout << "СТАТИСТИКА ОЧЕРЕДИ:" << endl;
    cout << "• Максимальная длина очереди: " << max_queue_length << endl;
    cout << "• Средняя длина очереди: " << total_queue_time / T_max << endl;
    cout << "• Доля времени с очередью: " << (total_queue_time > 0 ? "Да" : "Нет") << endl << endl;

    // ============================================================================
    // БЛОК 6: РАСПРЕДЕЛЕНИЕ ВЕРОЯТНОСТЕЙ СОСТОЯНИЙ СИСТЕМЫ
    // ============================================================================

    cout << "РАСПРЕДЕЛЕНИЕ ВЕРОЯТНОСТЕЙ СОСТОЯНИЙ:" << endl;
    cout << "k\tP(k)\tНарастающая\tРаботающие\tВ ремонте\tВ очереди" << endl;

    double cumulative_prob = 0.0;
    for (int i = 0; i <= n; i++) {
        double probability = time_in_state[i] / T_max;
        cumulative_prob += probability;

        int working = i;                    // Работающие автобусы
        int broken = n - i;                 // Всего сломанных
        int in_repair = min(broken, m);     // В ремонте
        int in_queue = max(0, broken - m);  // В очереди

        if (probability > 0.001) {  // Выводим только значимые состояния
            cout << i << "\t" << probability << "\t" << cumulative_prob
                << "\t\t" << working << "\t\t" << in_repair << "\t\t" << in_queue << endl;
        }
    }

    // ============================================================================
    // БЛОК 7: РАСЧЕТ КЛЮЧЕВЫХ ПОКАЗАТЕЛЕЙ ЭФФЕКТИВНОСТИ
    // ============================================================================

    cout << endl << "ПОКАЗАТЕЛИ ЭФФЕКТИВНОСТИ:" << endl;

    // Коэффициент использования ремонтных линий
    double total_repair_time = 0.0;
    for (int i = 0; i <= n; i++) {
        int broken = n - i;
        int busy_lines = min(broken, m);
        total_repair_time += time_in_state[i] * busy_lines;
    }
    double utilization = total_repair_time / (T_max * m);
    cout << "• Коэффициент использования ремонтных линий: " << utilization * 100 << "%" << endl;

    // Среднее количество работающих автобусов
    double avg_working = 0.0;
    for (int i = 0; i <= n; i++) {
        avg_working += i * (time_in_state[i] / T_max);
    }
    cout << "• Среднее количество работающих автобусов: " << avg_working << endl;

    // Эффективность системы
    double efficiency = avg_working / n * 100;
    cout << "• Эффективность использования автобусов: " << efficiency << "%" << endl;

    return 0;
}